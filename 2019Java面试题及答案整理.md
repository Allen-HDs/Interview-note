## 2019Java面试题及答案整理

#### 1.float f = 3.4;是否正确?

不正确.3.4是双精度数,将双精度型(double)赋值给浮点型(float)属于下转型会造成精度损失,因此需要强制类型转换float f= (float) 3.4;或者写成float = 3.4F; 

#### 2.类初始化和实例初始化

![](/img/QQ图片20190703124540.png)

**输出结果**:

(5) (1) (10) (6) (9) (3) (2) (9) (8) (7)

(9) (3) (2) (9) (8) (7)

**考点:**

- **类初始化过程**
  - 一个类要创建实例对象需要先加载并初始化该类
    - main方法所在的类需要先加载和初始化
  - 一个子类要初始化需要先初始化父类
  - 一个类初始化就是执行 <clinit>()方法
    - <clinit>()方法由静态类变量显示赋值代码和静态代码块组成
    - 类变量显式赋值代码和静态代码块代码从上倒下顺序执行
    - <clinit>()方法只执行一次
- **实例初始化过程**
  - 实力初始化执行就是执行<init>()方法
    - <init>()方法可能重载有多个,有几个构造器就有几个<init>()方法
    - <init>()方法由非静态实例变量显示赋值代码和非静态代码块代码、对应构造器代码组成
    - 非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行,而对应的构造器的代码最后执行
    - 每次创建实例对象,调用对应构造器,执行的就是对应的<init>()方法
    - <init>()方法的首行是super()或super(实参列表),即对应父类的<init>()方法
- **方法的重写**
  - 哪些方法不可以被重写
    - final方法
    - 静态方法
    - private等子类中不可见方法
  - 对象的多态性
    - 子类如果重写了父类的方法,通过子类对象调用的一定是子类重写过的代码
    - 非静态方法默认的调用对象是this
    - this对象在构造器或者说<init>()方法中就是正在创建的对象


#### 3.方法的参数传递机制

![](/img/微信图片_20190705123744.png)

运行结果:

![](/img/微信图片_20190705123841.png)

**考点:**

- **方法的参数传递机制**
  - 形参是基本数据类型
    - 传递数据值
  - 实参是引用数据类型
    - 传递地址值
    - 特殊的类型:String、包装类等对象不可变性
- String、包装类等对象的不可变性

**分析:**

![](/img/微信图片_20190705124827.png)

#### 4.成员变量与局部变量

- **声明的位置：**
  - 局部变量：方法体{}中，形参，代码块中
  - 成员变量：类中，方法外
    - 类变量：有static修饰
    - 实例变量：没有static修饰


- **修饰符**
  - 局部变量：final
  - 成员变量：public、protected、private、static、transient、final、volatile 
- **值存储位置：**
  - 局部变量：栈
  - 实例变量：堆
  - 类变量：方法区
- **作用域：**
  - 局部变量：从声明处开始，到所属的}结束
  - 实例变量：在当前类中“this.”(有时候this.可以省略)，在其他类中“对象名.”访问
  - 类变量：在当前类中“类名.”(有时候类名.可以省略)，在其他类中"类名."或"对象名."访问
- **生命周期：**
  - 局部变量：每一个线程，每一次调用执行都是新的生命周期
  - 实例变量：随着对象的创建而初始化，随着对象的被回收而消亡，每一个对象的实例变量都是独立的
  - 类变量：随着类的初始化而初始化，随着类的卸载而消亡，该类的所有对象的类变量都是共享的

![微信图片_20190707224301.png](/img/微信图片_20190708143519.png)

**当局部变量与xx（实例变量或类变量）变量重名时，如何区分？**

①.局部变量与实例变量重名

​	在实例变量前面加 **this**.

②.局部变量与类变量重名

​	在类变量前面加 **类名.**

#### 5.volatile是什么?

- **volatile是Java虚拟机提供的轻量级的同步机制**
  - 保证可见性
  - 不保证原子性
  - 禁止指令重排

#### 6.JMM内存模型之可见性

**JMM**(Java内存模型 **Java Memory Model**,简称JMM)本身是一种抽象的概念,**并不真实存在**,它描述的是一种规则,通过这种规范定义了程序中各个变量(包括实例字段、静态字段和构成数组对象的元素)的访问方式。

**JMM**关于同步的规定：

- 线程解锁前，必须把共享变量刷新回主内存；
- 线程加锁前，必修读取主内存的最新值到自己的工作内存；
- 加锁解锁是同一把锁

由于**JVM运行程序的实体是线程**，而每个线程创建时JVM都会为其**创建一个工作内存（有些地方称为栈空间）**，**工作内存是每个线程私有的数据区域**，而Java内存模型规定所有的**共享变量都存在主内存中**，主内存是共享内存区域，所有线程都可以访问，但**线程对变量的操作（读取赋值等）必须在工作内存中进行**，***首先是要将变量从主内存拷贝到自己的工作内存，然后对变量进行操作，操作完成后再将变量写回主内存***，不能直接操作主内存中的变量，各个线程中的工作内存中存着主内存中的变量副本拷贝，因此不同线程间无法访问对方的工作内存，线程之间的通信（传值）必须通过主内存来完成，其简要访问过程如下图所示：

![](/img/微信图片_20190830172602.png)

#### 7.JMM内存模型之原子性

原子性:不可分割,完整性。也即某个线程正在做某个具体业务的时候，中间不可以被加塞，或者被分割，需要整体完整。要么同时成功，要么同时失败。