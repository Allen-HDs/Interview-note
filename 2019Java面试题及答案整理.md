## 2019Java面试题及答案整理

#### 1.float f = 3.4;是否正确?

不正确.3.4是双精度数,将双精度型(double)赋值给浮点型(float)属于下转型会造成精度损失,因此需要强制类型转换float f= (float) 3.4;或者写成float = 3.4F; 

#### 2.类初始化和实例初始化

![](/img/QQ图片20190703124540.png)

**输出结果**:

(5) (1) (10) (6) (9) (3) (2) (9) (8) (7)

(9) (3) (2) (9) (8) (7)

**考点:**

- **类初始化过程**
  - 一个类要创建实例对象需要先加载并初始化该类
    - main方法所在的类需要先加载和初始化
  - 一个子类要初始化需要先初始化父类
  - 一个类初始化就是执行 <clinit>()方法
    - <clinit>()方法由静态类变量显示赋值代码和静态代码块组成
    - 类变量显式赋值代码和静态代码块代码从上倒下顺序执行
    - <clinit>()方法只执行一次
- **实例初始化过程**
  - 实力初始化执行就是执行<init>()方法
    - <init>()方法可能重载有多个,有几个构造器就有几个<init>()方法
    - <init>()方法由非静态实例变量显示赋值代码和非静态代码块代码、对应构造器代码组成
    - 非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行,而对应的构造器的代码最后执行
    - 每次创建实例对象,调用对应构造器,执行的就是对应的<init>()方法
    - <init>()方法的首行是super()或super(实参列表),即对应父类的<init>()方法
- **方法的重写**
  - 哪些方法不可以被重写
    - final方法
    - 静态方法
    - private等子类中不可见方法
  - 对象的多态性
    - 子类如果重写了父类的方法,通过子类对象调用的一定是子类重写过的代码
    - 非静态方法默认的调用对象是this
    - this对象在构造器或者说<init>()方法中就是正在创建的对象


#### 3.方法的参数传递机制

![](/img/微信图片_20190705123744.png)

运行结果:

![](/img/微信图片_20190705123841.png)

**考点:**

- **方法的参数传递机制**
  - 形参是基本数据类型
    - 传递数据值
  - 实参是引用数据类型
    - 传递地址值
    - 特殊的类型:String、包装类等对象不可变性
- String、包装类等对象的不可变性

**分析:**

![](/img/微信图片_20190705124827.png)

#### 4.成员变量与局部变量

- **声明的位置：**
  - 局部变量：方法体{}中，形参，代码块中
  - 成员变量：类中，方法外
    - 类变量：有static修饰
    - 实例变量：没有static修饰


- **修饰符**
  - 局部变量：final
  - 成员变量：public、protected、private、static、transient、final、volatile 
- **值存储位置：**
  - 局部变量：栈
  - 实例变量：堆
  - 类变量：方法区
- **作用域：**
  - 局部变量：从声明处开始，到所属的}结束
  - 实例变量：在当前类中“this.”(有时候this.可以省略)，在其他类中“对象名.”访问
  - 类变量：在当前类中“类名.”(有时候类名.可以省略)，在其他类中"类名."或"对象名."访问
- **生命周期：**
  - 局部变量：每一个线程，每一次调用执行都是新的生命周期
  - 实例变量：随着对象的创建而初始化，随着对象的被回收而消亡，每一个对象的实例变量都是独立的
  - 类变量：随着类的初始化而初始化，随着类的卸载而消亡，该类的所有对象的类变量都是共享的

![微信图片_20190707224301.png](/img/微信图片_20190708143519.png)

**当局部变量与xx（实例变量或类变量）变量重名时，如何区分？**

①.局部变量与实例变量重名

​	在实例变量前面加 **this**.

②.局部变量与类变量重名

​	在类变量前面加 **类名.**

#### 5.volatile是什么?

- **volatile是Java虚拟机提供的轻量级的同步机制**
  - 保证可见性
  - 不保证原子性
  - 禁止指令重排

#### 6.JMM(Java内存模型)

##### 6.1基本概念

**JMM**(Java内存模型 **Java Memory Model**,简称JMM)本身是一种抽象的概念,**并不真实存在**,它描述的是一种规则,通过这种规范定义了程序中各个变量(包括实例字段、静态字段和构成数组对象的元素)的访问方式。

**JMM**关于同步的规定：

- 线程解锁前，必须把共享变量刷新回主内存；
- 线程加锁前，必修读取主内存的最新值到自己的工作内存；
- 加锁解锁是同一把锁

由于**JVM运行程序的实体是线程**，而每个线程创建时JVM都会为其**创建一个工作内存（有些地方称为栈空间）**，**工作内存是每个线程私有的数据区域**，而Java内存模型规定所有的**共享变量都存在主内存中**，主内存是共享内存区域，所有线程都可以访问，但**线程对变量的操作（读取赋值等）必须在工作内存中进行**，***首先是要将变量从主内存拷贝到自己的工作内存，然后对变量进行操作，操作完成后再将变量写回主内存***，不能直接操作主内存中的变量，各个线程中的工作内存中存着主内存中的变量副本拷贝，因此不同线程间无法访问对方的工作内存，线程之间的通信（传值）必须通过主内存来完成，其简要访问过程如下图所示：

![](/img/微信图片_20190830172602.png)

##### 6.2.三大特性

- 可见性

代码实现：

```java
public class TestJMM {
    public static void main(String[] args) {		
		MyData myData = new MyData();
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "come in");
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            myData.addTo60();
            System.out.println(Thread.currentThread().getName() + "operate finished");
        }, "线程一").start();

        while (myData.number != 60) {
            // looping
        }
        System.out.println(Thread.currentThread().getName() + "number value is:" + myData.number);
          }
}


class MyData {
    volatile int number = 0;

    public void addTo60() {
        this.number = 60;
    }
}
```

如果不加 volatile 关键字，则主线程会进入死循环，加 volatile 则主线程能够退出，说明加了 volatile 关键字变量，当有一个线程修改了值，会马上被另一个线程感知到，当前值作废，从新从主内存中获取值。对其他线程可见，这就叫可见性。



- 原子性

原子性:不可分割,完整性。也即某个线程正在做某个具体业务的时候，中间不可以被加塞，或者被分割，需要整体完整。要么同时成功，要么同时失败。

代码实现:

```java
public class TestJMM {
    public static void main(String[] args) {
        MyData myData = new MyData();
        for (int i = 0; i < 20; i++) {
            new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    myData.addPlusPlus();
                    myData.incrementAndGet();
                }
            }, String.valueOf(i)).start();
        }
        while (Thread.activeCount() > 2) {
            Thread.yield();
        }
      	//此输出几乎不会达到20000
        System.out.println(Thread.currentThread().getName() + "\t value :" + myData.number);
      
      	//此时会输出20000
        System.out.println(Thread.currentThread().getName() + "\t value :" + myData.atomicInteger);

    }
}

class MyData {
    volatile int number = 0;

    //保证原子性的解决办法之一 加上synchronized
    public void addPlusPlus() {
        number++;
    }

    //保证原子性的解决办法之二
    AtomicInteger atomicInteger = new AtomicInteger(0);

    public void incrementAndGet(){
        atomicInteger.incrementAndGet();
    }
}
```

- 有序性

  - 计算机在执行程序时,为了提高性能,编译器和处理器常常会对指令做重排,一般分以下三种 

    ![](/img/微信图片_20190903132236.png)

    - 单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。

  - 处理器在进行重排序时必须要考虑指令之间的**数据依赖性**

  - 多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保持一致性时无法确定的，结果无法预测

  ```java
  public class ReSortSeqDemo {
      int a = 0;
      boolean flag = false;
      
      public void method01() {
          a = 1;           // flag = true;
                           // ----线程切换----
          flag = true;     // a = 1;
      }

      public void method02() {
          if (flag) {
              a = a + 3;
              System.out.println("a = " + a);
          }
      }
  }
  如果两个线程同时执行，method01 和 method02 如果线程 1 执行 method01 重排序了，然后切换的线程 2 执行 method02 就会出现不一样的结果。
  ```

##### 6.3禁止指令排序

volatile 实现禁止指令排序的优化,从而避免了多线程环境下程序出现乱序的现象

先了解一个概念,内存屏障(Memory Barrier)又称内存棚栏,是一个CPU指令,它的作用有两个:

- 保证特定操作的执行顺序
- 保证某些变量的内存可见性(利用该特性实现 volatile 的内存可见性)

由于编译器个处理器都能执行指令重排序优化，如果在指令间插入一条 Memory Barrier 则会告诉编译器和 CPU，不管什么指令都不能个这条 Memory Barrier 指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后执行重排序优化。内存屏障另一个作用是强制刷出各种 CPU 缓存数据，因此任何 CPU 上的线程都能读取到这些数据的最新版本。

下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图：

![](/img/微信图片_20190904185801.png)

下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图：

![](/img/21ebc7e8190c4966948c4ef4424088be_th.png)

##### 6.4.线程安全性保证

- 工作内存与主内存同步延迟现象导致可见性问题
  - 可以使用 synchronized 或 volatile 关键字解决,它们可以使一个线程修改后的变量立即对其他线程可见
- 对于指令重排导致可见性问题和有序性问题
  - 可以利用volatile关键字解决,因为volatile的另一个作用就是禁止指令重排

#### 7.你在哪些地方用到过volatile

##### 单例

```java
public class SingletonDemo {
    private static SingletonDemo install = null;
    private SingletonDemo(){
        System.out.println("我是私有构造器: \t SingletonDemo");
    }

    public static SingletonDemo getinstall(){
        if (null == install){
            install = new SingletonDemo();
        }
        return install;
    }

    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newFixedThreadPool(10);
        for (int i = 0; i < 10; i++) {
            threadPool.execute(()-> SingletonDemo.getinstall());
        }
        threadPool.shutdown();
    }
}

//发现构造器里的内容会多次输出
```

##### 双重锁单例:DCL(Double Check Lock)

- 代码:

```java
public class SingletonDemo {
    private static SingletonDemo install = null;

    private SingletonDemo() {
        System.out.println("我是私有构造器: \t SingletonDemo");
    }

    public static SingletonDemo getinstall() {
        if (null == install) {
            synchronized (SingletonDemo.class) {
                if (null == install) {
                    install = new SingletonDemo();
                }
            }
        }
        return install;
    }

    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newFixedThreadPool(10);
        for (int i = 0; i < 10; i++) {
            threadPool.execute(() -> SingletonDemo.getinstall());
        }
        threadPool.shutdown();
    }
}
```

- 如果没有加volatile就不一定是线程安全的,原因是指令重排序的存在,加入volatile可以禁止指令重排序

  - 原因是在于某一个线程执行到第一次检测,读取到的instance不为null时,**instance的引用对象可能还没有完成初始化**

  - instance = new SingletonDemo()可以分为以下三步完成

    ```java
    memory = allocate();  // 1.分配对象空间
    instance(memory);     // 2.初始化对象
    instance = memory;    // 3.设置instance指向刚分配的内存地址，此时instance != null
    ```

  - 步骤2 和 步骤3 不存在依赖关系,而且无论重排前还是重排后程序的执行结果在单线程中并没有改变,因此这种优化是允许的。

  - 发生重排:

    ```java
    memory = allocate();  // 1.分配对象空间
    instance = memory;    // 3.设置instance指向刚分配的内存地址，此时instance != null，但对象还没有初始化完成
    instance(memory);     // 2.初始化对象
    ```


  - 所以不加volatile返回的实例不为空,但可能是未初始化的实例

#### 8.CAS你知道吗

```java
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(5);
        // 获取真实值，并替换为相应的值
        boolean compareAndSet = atomicInteger.compareAndSet(5, 2019);//期望值和真实值一样就修改
        System.out.println(compareAndSet+"\t current data:"+atomicInteger.get());
		//true	 current data:2019
      
        boolean compareAndSet1 = atomicInteger.compareAndSet(5, 1024);//期望值和真实值一样就修改
        System.out.println(compareAndSet1+"\t current data:"+atomicInteger.get());
     	//false	 current data:2019
    }
```

##### 8.1CAS底层原理?谈谈对Unsafe的理解?

```java
AtomicInteger.incrementAndGet();
```

```java
    /**
     * Atomically increments by one the current value.
     *
     * @return the updated value
     */
    public final int incrementAndGet() {
        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
    }
```

引出一个问题：UnSafe 类是什么？

**Unsafe类**

```java
public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;

    // setup to use Unsafe.compareAndSwapInt for updates
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }

    private volatile int value;
  	// ...
  }
```

- Unsafe是CAS的核心类,由于Java无法访问底层系统,而需要通过本地(native)方法来访问,Unsafe类相当于一个后门,基于该类可以直接操作特定内存数据。Unsafe类存在于 sun.misc 包中,其内部方法操作可以像 C 指针一样直接操作内存,因为Java中CAS执行操作依赖于Unsafe类。
- 变量 valueOffset，表示该变量值在内存中的偏移量，因为 Unsafe 就是根据内存偏移量来获取数据的。
- 变量value 用 volatile 修饰，保证了多线程之间的内存可见性 

##### CAS是什么？

- CAS的全称　Compare And Swap,它是一条CPU并发
- 它的功能是判断内存某一个位置的值是否为预期,如果是则更改这个值,这个过程就是原子的
- CAS并发原体现在Java语言中就是 sun.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现出CAS的汇编指令。这是一种完全依赖硬件的功能，通过它实现了原子操作。由于CAS是一种系统源语，源语属于操作系统用语范畴，是由若干条指令组成，用于完成某一个功能的过程，并且源语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条原子指令，不会造成所谓的数据不一致的问题。
- 分析一下getAndAddInt这个方法

```java
// unsafe.getAndAddInt
public final int getAndAddInt(Object obj, long valueOffset, long expected, int val) {
    int temp;
    do {
        temp = this.getIntVolatile(obj, valueOffset);  // 获取快照值
    } while (!this.compareAndSwap(obj, valueOffset, temp, temp + val));  // 如果此时 temp 没有被修改，就能退出循环，否则重新获取
    return temp;
}
```

